<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.47">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Appendix F — Mathematics – Reaction Engineering Basics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./apndx_useful_eqns.html" rel="next">
<link href="./apndx_derivations.html" rel="prev">
<link href="./Graphics/BuffaloBadger_16_16.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="http://buffalobadger.github.io" class="navbar-brand navbar-brand-logo">
    <img src="./Graphics/Banner.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="http://buffalobadger.github.io/RE_Basics"> 
<span class="menu-text">Reaction Engineering Basics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="http://buffalobadger.github.io/SCoRE"> 
<span class="menu-text">SCoRE</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="http://buffalobadger.github.io/ToTaL_Engineering"> 
<span class="menu-text">ToTaL Engineering</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="http://buffalobadger.github.io/The_Sett"> 
<span class="menu-text">The Sett</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="http://buffalobadger.github.io/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./apndx_prereq_knowledge.html">Appendices</a></li><li class="breadcrumb-item"><a href="./apndx_mathematics.html"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Mathematics</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Introduction</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_1_intro_safety_ethics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Reaction Engineering, Ethics and Safety</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_1_rxns_reactors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Reactions and Reactors</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_1_reaction_progress.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Reaction Progress</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Rate Expressions</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_2_rates_and_expressions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Reaction Rates and Rate Expressions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_2_mechanisms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Reaction Mechanisms and Mechanistic Rate Expressions</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Reaction Engineering Analysis</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_3_react_eng_models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Reaction Engineering Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_3_reaction_engineering_tasks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Reaction Engineering Tasks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_3_formulating_calcs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Completing Reaction Engineering Tasks</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Modeling Ideal Reactors</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_4_bstr_analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">BSTR Analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_4_sbstr_analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">SBSTR Analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_4_non_continuous_design.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Design of Non-Continuous Reactors</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_4_cstr_analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">CSTR Analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_4_pfr_analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">PFR Analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_4_continuous_design.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Design of Continuous Reactors</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Modeling Ideal Reactor Systems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_5_reactor_networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Reactor Networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_5_thermally_backmixed_pfr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Thermally Back-Mixed PFRs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_5_recycle_pfr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Recycle PFRs</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Kinetics Data Analysis</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_6_data_generation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Generation and Analysis of Kinetics Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_6_bstr_data_analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Analysis of Kinetics Data from a BSTR</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_6_cstr_data_analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Analysis of Kinetics Data from a CSTR</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_6_pfr_data_analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Analysis of Kinetics Data from a PFR</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true">
 <span class="menu-text">Modeling Non-Ideal Reactors</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_7_age_function.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">The Age Distribution Functions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_7_segregated_flow_model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">A Segregated Flow Reactor Model</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_7_axial_dispersion_model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">The Steady-State Axial Dispersion Model</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./section_7_zoned_model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Zoned Reactor Models</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apndx_prereq_knowledge.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Prerequisite Knowledge</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apndx_nomenclature.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Terminology and Sign Conventions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apndx_reaction_thermo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Reaction Thermodynamics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apndx_kinetics_theories.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Kinetics Theories</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apndx_derivations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Derivation of Model Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apndx_mathematics.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Mathematics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apndx_useful_eqns.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">G</span>&nbsp; <span class="chapter-title">Frequently Used Equations</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#quantities-appearing-in-equations" id="toc-quantities-appearing-in-equations" class="nav-link active" data-scroll-target="#quantities-appearing-in-equations"><span class="header-section-number">F.1</span> Quantities Appearing in Equations</a></li>
  <li><a href="#ates" id="toc-ates" class="nav-link" data-scroll-target="#ates"><span class="header-section-number">F.2</span> ATEs</a></li>
  <li><a href="#odes" id="toc-odes" class="nav-link" data-scroll-target="#odes"><span class="header-section-number">F.3</span> ODEs</a>
  <ul class="collapse">
  <li><a href="#ivodes" id="toc-ivodes" class="nav-link" data-scroll-target="#ivodes"><span class="header-section-number">F.3.1</span> IVODEs</a></li>
  <li><a href="#daes" id="toc-daes" class="nav-link" data-scroll-target="#daes"><span class="header-section-number">F.3.2</span> DAEs</a></li>
  <li><a href="#bvodes" id="toc-bvodes" class="nav-link" data-scroll-target="#bvodes"><span class="header-section-number">F.3.3</span> BVODEs</a></li>
  </ul></li>
  <li><a href="#important-equation-formats" id="toc-important-equation-formats" class="nav-link" data-scroll-target="#important-equation-formats"><span class="header-section-number">F.4</span> Important Equation Formats</a>
  <ul class="collapse">
  <li><a href="#sec-apndx_residual_expressions" id="toc-sec-apndx_residual_expressions" class="nav-link" data-scroll-target="#sec-apndx_residual_expressions"><span class="header-section-number">F.4.1</span> Residual Expressions</a></li>
  <li><a href="#sec-apndx_derivative_expressions" id="toc-sec-apndx_derivative_expressions" class="nav-link" data-scroll-target="#sec-apndx_derivative_expressions"><span class="header-section-number">F.4.2</span> Derivative Expressions</a></li>
  </ul></li>
  <li><a href="#solving-equations" id="toc-solving-equations" class="nav-link" data-scroll-target="#solving-equations"><span class="header-section-number">F.5</span> Solving Equations</a>
  <ul class="collapse">
  <li><a href="#sec-apndx_solve_ates" id="toc-sec-apndx_solve_ates" class="nav-link" data-scroll-target="#sec-apndx_solve_ates"><span class="header-section-number">F.5.1</span> Solving ATEs</a></li>
  <li><a href="#sec-apndx_solve_ivodes" id="toc-sec-apndx_solve_ivodes" class="nav-link" data-scroll-target="#sec-apndx_solve_ivodes"><span class="header-section-number">F.5.2</span> Solving IVODEs</a></li>
  <li><a href="#sec-apndx_solve_daes" id="toc-sec-apndx_solve_daes" class="nav-link" data-scroll-target="#sec-apndx_solve_daes"><span class="header-section-number">F.5.3</span> Solving DAEs</a></li>
  <li><a href="#sec-apndx_solve_bvodes" id="toc-sec-apndx_solve_bvodes" class="nav-link" data-scroll-target="#sec-apndx_solve_bvodes"><span class="header-section-number">F.5.4</span> Solving BVODEs</a></li>
  </ul></li>
  <li><a href="#sec-apndx_parameter_est" id="toc-sec-apndx_parameter_est" class="nav-link" data-scroll-target="#sec-apndx_parameter_est"><span class="header-section-number">F.6</span> Estimating Parameters</a>
  <ul class="collapse">
  <li><a href="#fitting-function-input" id="toc-fitting-function-input" class="nav-link" data-scroll-target="#fitting-function-input"><span class="header-section-number">F.6.1</span> Fitting Function Input</a></li>
  <li><a href="#how-fitting-functions-work" id="toc-how-fitting-functions-work" class="nav-link" data-scroll-target="#how-fitting-functions-work"><span class="header-section-number">F.6.2</span> How Fitting Functions Work</a></li>
  <li><a href="#fitting-function-issues" id="toc-fitting-function-issues" class="nav-link" data-scroll-target="#fitting-function-issues"><span class="header-section-number">F.6.3</span> Fitting Function Issues</a></li>
  <li><a href="#fitting-function-return-values" id="toc-fitting-function-return-values" class="nav-link" data-scroll-target="#fitting-function-return-values"><span class="header-section-number">F.6.4</span> Fitting Function Return Values</a></li>
  <li><a href="#assessing-the-accuracy-of-the-fitted-model" id="toc-assessing-the-accuracy-of-the-fitted-model" class="nav-link" data-scroll-target="#assessing-the-accuracy-of-the-fitted-model"><span class="header-section-number">F.6.5</span> Assessing the Accuracy of the Fitted Model</a></li>
  <li><a href="#formulating-the-fitting-of-a-model-to-experimental-data" id="toc-formulating-the-fitting-of-a-model-to-experimental-data" class="nav-link" data-scroll-target="#formulating-the-fitting-of-a-model-to-experimental-data"><span class="header-section-number">F.6.6</span> Formulating the Fitting of a Model to Experimental Data</a></li>
  </ul></li>
  <li><a href="#symbols-used-in-this-appendix" id="toc-symbols-used-in-this-appendix" class="nav-link" data-scroll-target="#symbols-used-in-this-appendix"><span class="header-section-number">F.7</span> Symbols Used in This Appendix</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./apndx_prereq_knowledge.html">Appendices</a></li><li class="breadcrumb-item"><a href="./apndx_mathematics.html"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Mathematics</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-apndx_mathematics" class="quarto-section-identifier">Appendix F — Mathematics</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>Reaction Engineering Basics</em> assumes that reactor model equations will be solved numerically. This appendix presents an overview of the types of equations that are encountered, the quantities that appear in them, and their numerical solution. It also considers estimation of parameters using numerical methods.</p>
<section id="quantities-appearing-in-equations" class="level2" data-number="F.1">
<h2 data-number="F.1" class="anchored" data-anchor-id="quantities-appearing-in-equations"><span class="header-section-number">F.1</span> Quantities Appearing in Equations</h2>
<p>Equations establish a relationship among different quantities. When solving equations numerically, the quantities appearing in them can be grouped based upon the way they are used or processed. For the purposes of this appendix, each quantity appearing in an equation can be assigned to one of the following categories.</p>
<dl>
<dt>Known Constants</dt>
<dd>
Quantities whose values are known and do not change throughout the analysis.
</dd>
<dt>Variables</dt>
<dd>
Quantities whose values are not known, but are found by solving the equations. In differential equations variables are further categorized as the independent variable or a dependent variable.
</dd>
<dt>Derivatives</dt>
<dd>
Quantities representing the change of a dependent variable relative to a change in the independent variable.
</dd>
<dt>Additional Unknowns</dt>
<dd>
Quantities that are not variables and whose values are not known.
</dd>
<dt>Parameters</dt>
<dd>
Quantities whose values are constant any one time the equations are solved, but that have different values each time they are solved. Parameters can be further categorized as being either specified or to be estimated.
</dd>
</dl>
</section>
<section id="ates" class="level2" data-number="F.2">
<h2 data-number="F.2" class="anchored" data-anchor-id="ates"><span class="header-section-number">F.2</span> ATEs</h2>
<p>Algebraic-transcendental equations (ATEs) are one of the equation types that must be solved when performing reaction engineering tasks. (The acronym ATE is used in this book, but it is not generally used in other books or online.) In the context of <em>Reaction Engineering Basics,</em> ATEs are easily identifiable because they are the only equation type that does not contain derivatives. Slightly more specifically, a set of ATEs is a group of 1 or more mathematical equations that may involve or contain math operations (addition, subtraction, multiplication, and division). Terms in ATEs can be exponents or bases that are raised to some power, and they can appear in transcendental functions. Exponential functions are the most common transcendental functions appearing in the ATEs found in <em>Reaction Engineering Basics</em>. They arise any time an equation includes a rate coefficient that displays Arrhenius temperature dependence, <a href="section_2_rates_and_expressions.html#eq-arrhenius" class="quarto-xref">Equation&nbsp;<span>4.8</span></a>.</p>
</section>
<section id="odes" class="level2" data-number="F.3">
<h2 data-number="F.3" class="anchored" data-anchor-id="odes"><span class="header-section-number">F.3</span> ODEs</h2>
<p>Some of the ideal reactor design equations are partial differential equations, but in <em>Reaction Engineering Basics,</em> they are always simplified to linear, first-order, ordinary differential equations (ODEs) before they need to be solved. As a reminder, in linear, first-order, ordinary differential equations, only ordinary first derivatives appear, they are not multiplied or divided by other derivatives, and they are not raised to any power other than one.</p>
<p>In sets of ODEs that are solved in <em>Reaction Engineering Basics,</em> the independent variable is the same in every derivative in the set. A set of <span class="math inline">\(N\)</span> ODEs must contain the derivatives of <span class="math inline">\(N\)</span> dependent variables with respect to the independent variable. The set of ODEs applies within a continuous interval of the independent variable. Each of the dependent variables then span their own corresponding range of values.</p>
<p>Most generally, a set of ODEs will take the form shown in Equations <a href="#eq-example-ode-1" class="quarto-xref"><span>F.1</span></a> through <a href="#eq-example-ode-4" class="quarto-xref"><span>F.4</span></a>. In those equations <span class="math inline">\(z\)</span> is the independent variable; <span class="math inline">\(y_1\)</span>, <span class="math inline">\(y_2\)</span>, <span class="math inline">\(y_3\)</span>, and <span class="math inline">\(y_4\)</span> are the dependent variables; and <span class="math inline">\(m_{1,1}\)</span> through <span class="math inline">\(m_{4,4}\)</span> and <span class="math inline">\(g_1\)</span> through <span class="math inline">\(g_4\)</span> can be constants (including zero) or functions of the independent and dependent variables. While four equations are being used here for illustration purposes, there can be any number of ordinary differential equations in the set as long as the number of ordinary differential equations is equal to the number of dependent variables, and there is only one independent variable.</p>
<p><span id="eq-example-ode-1"><span class="math display">\[
m_{1,1}\frac{dy_1}{dz} + m_{1,2}\frac{dy_2}{dz} + m_{1,3}\frac{dy_3}{dz} + m_{1,4}\frac{dy_4}{dz} = g_1
\tag{F.1}\]</span></span></p>
<p><span id="eq-example-ode-2"><span class="math display">\[
m_{2,1}\frac{dy_1}{dz} + m_{2,2}\frac{dy_2}{dz} + m_{2,3}\frac{dy_3}{dz} + m_{2,4}\frac{dy_4}{dz} = g_2
\tag{F.2}\]</span></span></p>
<p><span id="eq-example-ode-3"><span class="math display">\[
m_{3,1}\frac{dy_1}{dz} + m_{3,2}\frac{dy_2}{dz} + m_{3,3}\frac{dy_3}{dz} + m_{3,4}\frac{dy_4}{dz} = g_3
\tag{F.3}\]</span></span></p>
<p><span id="eq-example-ode-4"><span class="math display">\[
m_{4,1}\frac{dy_1}{dz} + m_{4,2}\frac{dy_2}{dz} + m_{4,3}\frac{dy_3}{dz}  + m_{4,4}\frac{dy_4}{dz} = g_4
\tag{F.4}\]</span></span></p>
<p>In reactor design equations the dependent variables (<span class="math inline">\(y_i\)</span>’s above) will be things such as molar amounts or molar flow rates, temperature, pressure, and volumes or volumetric flow rates. The independent variable is either the distance from the reactor inlet (<span class="math inline">\(z\)</span>) or time (<span class="math inline">\(t\)</span>).</p>
<section id="ivodes" class="level3" data-number="F.3.1">
<h3 data-number="F.3.1" class="anchored" data-anchor-id="ivodes"><span class="header-section-number">F.3.1</span> IVODEs</h3>
<p>The second equation type that must be solved when performing reaction engineering tasks is called an initial-value ODE (IVODE). ODEs apply over a continuous interval of the independent variable, <span class="math inline">\(z\)</span>, beginning at its initial value and increasing or decreasing monotonically to its final value. Very often the initial value can be defined to be <span class="math inline">\(z=0\)</span>, and <span class="math inline">\(z\)</span> increases to its final value. At any value of the independent variable, each dependent variable has a corresponding value. The values of the dependent variables corresponding to the initial value of <span class="math inline">\(z\)</span> are called thier initial values, and those corresponding to the final value of <span class="math inline">\(z\)</span> are their final values. The distinguishing characteristics of IVODEs are that (a) all of the initial values are known or can be calculated directly and (b) only one final value (either for the independent variable or for one of the dependent variables) is known or can be calculated directly.</p>
</section>
<section id="daes" class="level3" data-number="F.3.2">
<h3 data-number="F.3.2" class="anchored" data-anchor-id="daes"><span class="header-section-number">F.3.2</span> DAEs</h3>
<p>Differential-algebraic equations (DAEs) are the final type of equation that must be solved when completing tasks in <em>Reaction Engineering Basics.</em> In a set of DAEs, a set of IVODEs is coupled to set of ATEs. The distinguishing feature of a set of DAEs is that neither the set of IVODEs nor the set of ATEs can be solved independently of the other set.</p>
<p>There are two situations where DAEs are encountered in <em>Reaction Engineering Basics.</em> In the first situation, either a constant appearing in the IVODEs or the initial value of one of the dependent variables is an additional unknown. At the same time, two final values are known, and the additional unknown is implicitly related to one of the known final values. The second situation is encountered when analyzing thermally backmixed and recycle PFRs. In this situation, both the initial and final values for one or more dependent variables are unknown, but they are explicitly related through ATEs.</p>
</section>
<section id="bvodes" class="level3" data-number="F.3.3">
<h3 data-number="F.3.3" class="anchored" data-anchor-id="bvodes"><span class="header-section-number">F.3.3</span> BVODEs</h3>
<p>The design equations for the axial dispersion reactor model are boundary-value ODEs (BVODEs). BVODEs are the third type of equation that must be solved when completing reaction engineering tasks. Criteria for identifying them are not needed because the only time they are encountered in <em>Reaction Engineering Basics</em> is when modeling a reactor with axial dispersion. The limits of the continuous interval of the independent variable for a set of BVODEs are referred to as its upper and lower bounds, and not as initial and final values.</p>
</section>
</section>
<section id="important-equation-formats" class="level2" data-number="F.4">
<h2 data-number="F.4" class="anchored" data-anchor-id="important-equation-formats"><span class="header-section-number">F.4</span> Important Equation Formats</h2>
<p>When solving equations numerically, they often must be formatted appropriately. ATEs must be rewritten as a corresponding set of residuals expressions, and IVODES must be converted to a set of derivative expressions. These equation formats are considered in this section.</p>
<section id="sec-apndx_residual_expressions" class="level3" data-number="F.4.1">
<h3 data-number="F.4.1" class="anchored" data-anchor-id="sec-apndx_residual_expressions"><span class="header-section-number">F.4.1</span> Residual Expressions</h3>
<p>In preparation for numerically solving a set of ATEs, each equation must be rewritten as a residual expression. Doing so is trivially simple. If there is a zero on either side of the equals sign, no rearrangement is necessary. If not, everything on one side of the equals sign should be subtracted from both sides of the equation. This will result in an equation with a zero on one side of the equals sign. The nonzero side of that equation is called a residual. A residual expression is created by choosing a variable to represent the residual and setting it equal to the nonzero side of the equation. In <em>Reaction Engineering Basics,</em> <span class="math inline">\(\epsilon\)</span> is usually used to represent residuals.</p>
<p>As an example, consider the typical ATE mole balance shown in <a href="#eq-ate_not_as_residual" class="quarto-xref">Equation&nbsp;<span>F.5</span></a>. It does not have a zero on either side of the equals sign, so the right side of the equation, <span class="math inline">\(\dot{n}_{A,1} + rV\)</span>, is subtracted from both sides, leading to <a href="#eq-ate_with_zero" class="quarto-xref">Equation&nbsp;<span>F.6</span></a>. Letting <span class="math inline">\(\epsilon\)</span> represent the residual, the corresponding residual expression, <a href="#eq-ate_as_residual" class="quarto-xref">Equation&nbsp;<span>F.7</span></a>, is written by setting <span class="math inline">\(\epsilon\)</span> equal to the non-zero side of <a href="#eq-ate_with_zero" class="quarto-xref">Equation&nbsp;<span>F.6</span></a></p>
<p><span id="eq-ate_not_as_residual"><span class="math display">\[
\dot{V}C_{A,0} = \dot{n}_{A,1} + rV
\tag{F.5}\]</span></span></p>
<p><span id="eq-ate_with_zero"><span class="math display">\[
\dot{V}C_{A,0} - \dot{n}_{A,1} - rV =0
\tag{F.6}\]</span></span></p>
<p><span id="eq-ate_as_residual"><span class="math display">\[
\epsilon = \dot{V}C_{A,0} - \dot{n}_{A,1} - rV
\tag{F.7}\]</span></span></p>
<p>If a set of <span class="math inline">\(N\)</span> ATEs is being solved, they must be converted into a set of <span class="math inline">\(N\)</span> residual expressions. In general each residual can be a function of all of the ATE variables. Substitution of a solution (i.e.&nbsp;a set of ATE variables that solve the ATEs) will cause all of the residuals to evaluate to zero.</p>
</section>
<section id="sec-apndx_derivative_expressions" class="level3" data-number="F.4.2">
<h3 data-number="F.4.2" class="anchored" data-anchor-id="sec-apndx_derivative_expressions"><span class="header-section-number">F.4.2</span> Derivative Expressions</h3>
<p>In preparation for solving a set of <span class="math inline">\(N\)</span> IVODEs, they should be rearranged into a set of derivative functions if they aren’t already in that form. For example, Equations <a href="#eq-example-ode-1" class="quarto-xref"><span>F.1</span></a> through <a href="#eq-example-ode-4" class="quarto-xref"><span>F.4</span></a> need to be converted to derivative expressions of the form shown in Equations <a href="#eq-example-vector-ode-1" class="quarto-xref"><span>F.8</span></a> through <a href="#eq-example-vector-ode-4" class="quarto-xref"><span>F.11</span></a> where <span class="math inline">\(f_1\)</span>, <span class="math inline">\(f_2\)</span>, <span class="math inline">\(f_3\)</span>, and <span class="math inline">\(f_4\)</span> each may be a function of <span class="math inline">\(z\)</span>, <span class="math inline">\(y_1\)</span>, <span class="math inline">\(y_2\)</span>, <span class="math inline">\(y_3\)</span>, and <span class="math inline">\(y_4\)</span>.</p>
<p><span id="eq-example-vector-ode-1"><span class="math display">\[
\frac{dy_1}{dz}  = f_1
\tag{F.8}\]</span></span></p>
<p><span id="eq-example-vector-ode-2"><span class="math display">\[
\frac{dy_2}{dz} = f_2
\tag{F.9}\]</span></span></p>
<p><span id="eq-example-vector-ode-3"><span class="math display">\[
\frac{dy_3}{dz} = f_3
\tag{F.10}\]</span></span></p>
<p><span id="eq-example-vector-ode-4"><span class="math display">\[
\frac{dy_4}{dz} = f_4
\tag{F.11}\]</span></span></p>
<p>That can be accomplished by algebraic manipulation of Equations <a href="#eq-example-ode-1" class="quarto-xref"><span>F.1</span></a> through <a href="#eq-example-ode-4" class="quarto-xref"><span>F.4</span></a>, but it is particularly straightforward if the original IVODEs are written as a matrix equation. The coefficients in Equations <a href="#eq-example-ode-1" class="quarto-xref"><span>F.1</span></a> through <a href="#eq-example-ode-4" class="quarto-xref"><span>F.4</span></a>, <span class="math inline">\(m_{1,1}\)</span>, <span class="math inline">\(m_{1,2}\)</span>, etc., can be used to construct a so-called mass matrix, <span class="math inline">\(\boldsymbol{M}\)</span>, as shown in <a href="#eq-mass-matrix" class="quarto-xref">Equation&nbsp;<span>F.12</span></a>, the dependent variables can be used to construct a column vector, <span class="math inline">\(\underline{y}\)</span>, as in equation <a href="#eq-dependent-var-vector" class="quarto-xref">Equation&nbsp;<span>F.13</span></a>, and the functions, <span class="math inline">\(g_1\)</span>, <span class="math inline">\(g_2\)</span>, <span class="math inline">\(g_3\)</span>, and <span class="math inline">\(g_4\)</span>, can be used to construct a column vector, <span class="math inline">\(\underline{g}\)</span>, as in equation <a href="#eq-function-vector" class="quarto-xref">Equation&nbsp;<span>F.14</span></a>.</p>
<p><span id="eq-mass-matrix"><span class="math display">\[
\boldsymbol{M} = \begin{bmatrix} m_{1,1} \ m_{1,2} \ m_{1,3} \ m_{1,4} \\m_{2,1} \ m_{2,2} \ m_{2,3} \ m_{2,4} \\m_{3,1} \ m_{3,2} \ m_{3,3} \ m_{3,4} \\ m_{4,1} \ m_{4,2} \ m_{4,3} \ m_{4,4}  \end{bmatrix}
\tag{F.12}\]</span></span></p>
<p><span id="eq-dependent-var-vector"><span class="math display">\[
\underline{y} = \begin{bmatrix} y_1 \\ y_2 \\ y_3 \\ y_4 \end{bmatrix}
\tag{F.13}\]</span></span></p>
<p><span id="eq-function-vector"><span class="math display">\[
\underline{g} = \begin{bmatrix} g_1 \\ g_2 \\ g_3 \\ g_4 \end{bmatrix}
\tag{F.14}\]</span></span></p>
<p>Equations <a href="#eq-example-ode-1" class="quarto-xref"><span>F.1</span></a> through <a href="#eq-example-ode-4" class="quarto-xref"><span>F.4</span></a> then can be written as a matrix equation, <a href="#eq-matrix-form-ivode" class="quarto-xref">Equation&nbsp;<span>F.15</span></a>. Pre-multiplying each side of <a href="#eq-matrix-form-ivode" class="quarto-xref">Equation&nbsp;<span>F.15</span></a> by the inverse of the mass matrix yields the desired derivative expressions, <a href="#eq-matrix-form-of-vector-ivodes" class="quarto-xref">Equation&nbsp;<span>F.16</span></a>. That is, comparing <a href="#eq-matrix-form-of-vector-ivodes" class="quarto-xref">Equation&nbsp;<span>F.16</span></a> to Equations <a href="#eq-example-vector-ode-1" class="quarto-xref"><span>F.8</span></a> through <a href="#eq-example-vector-ode-4" class="quarto-xref"><span>F.11</span></a>, it is apparent that they are equivalent with <span class="math inline">\(f_1\)</span>, <span class="math inline">\(f_2\)</span>, <span class="math inline">\(f_3\)</span>, and <span class="math inline">\(f_4\)</span> given by <a href="#eq-g-in-terms-of-f" class="quarto-xref">Equation&nbsp;<span>F.17</span></a>.</p>
<p><span id="eq-matrix-form-ivode"><span class="math display">\[
\boldsymbol{M}\frac{d}{dz}\underline{y} = \underline{g}
\tag{F.15}\]</span></span></p>
<p><span id="eq-matrix-form-of-vector-ivodes"><span class="math display">\[
\frac{d}{dz}\underline{y} = \boldsymbol{M}^{-1} \underline{g}
\tag{F.16}\]</span></span></p>
<p><span id="eq-g-in-terms-of-f"><span class="math display">\[
\begin{bmatrix} f_1 \\ f_2 \\ f_3 \\ f_4 \end{bmatrix} = \underline{f} = \boldsymbol{M}^{-1} \underline{g}
\tag{F.17}\]</span></span></p>
</section>
</section>
<section id="solving-equations" class="level2" data-number="F.5">
<h2 data-number="F.5" class="anchored" data-anchor-id="solving-equations"><span class="header-section-number">F.5</span> Solving Equations</h2>
<p>Equations are solved numerically by calling a function, known as a solver, from a mathematics software package. The documentation for the solver will specifiy the details including the arguments that must be provided and the results that will be returned. It will also stipulate the format and order in which the arguments must be passed and results will be returned.</p>
<p>The equations to be solved must be provided to the solver, and most commonly they are provided in the form of a function. The engineer solving the equations must write this function, but the solver documentation will specify its arguments, their format and their order and the values it must return, their format and their order. The engineer cannot add or remove arguments or return values because the solver will call this function assuming it meets the solver’s specifications. An important consequence of this is that if the function providing the equations requires input other than the specified arguments, that input must be made available by some other means.</p>
<p>There are numerous mathematics software packages that provide solvers. For any one type of solver (ATE, IVODE, BVODE) the specifications may vary from one mathematics software package to the next, but the required input is essentially the same irrespective of the software package. The information provided in <em>Reaction Engineering Basics</em> is sufficient for understanding the examples that are presented, and it is presented in a manner that allows the reader to solve equations using whatever mathematics software they choose.</p>
<p>Readers who seek further details are encouraged to consult the documentation for the software package they are using or to consult references on numerical methods.</p>
<section id="sec-apndx_solve_ates" class="level3" data-number="F.5.1">
<h3 data-number="F.5.1" class="anchored" data-anchor-id="sec-apndx_solve_ates"><span class="header-section-number">F.5.1</span> Solving ATEs</h3>
<p>A set of <span class="math inline">\(N\)</span> ATEs can be solved to find the values of the <span class="math inline">\(N\)</span> variables appearing in the ATEs. A set of ATEs can have more than one solution. An ATE solver is a computer function that solves a set of ATEs numerically. This sub-appendix describes the input required by ATE solvers, how they work, the results they return, and potential issues that can arise when using them.</p>
<section id="ate-solver-input" class="level4" data-number="F.5.1.1">
<h4 data-number="F.5.1.1" class="anchored" data-anchor-id="ate-solver-input"><span class="header-section-number">F.5.1.1</span> ATE Solver Input</h4>
<p>Typically, an ATE solver must be provided with two inputs. The first is an initial guess for the solution, and the second is a residuals function. Depending upon the mathematics software being used, the solver may accept other input. The order and formatting of the arguments also vary between mathematics software packages.</p>
<section id="the-initial-guess-for-the-ate-variables" class="level5" data-number="F.5.1.1.1">
<h5 data-number="F.5.1.1.1" class="anchored" data-anchor-id="the-initial-guess-for-the-ate-variables"><span class="header-section-number">F.5.1.1.1</span> The Initial Guess for the ATE Variables</h5>
<p>As just noted, when an ATE solver is first called, it must be provided with an initial guess for a solution. Providing an acceptable guess is not usually difficult. In reaction engineering analyses, the ATE variables have a physical meaning. That, together with a qualitative understanding of reactor performance, provides guidance for making an initial guess. An initial guess that involves small changes in reacting fluid temperature and reagent flow rates will generally result in convergence to a solution.</p>
<p>In this book, examples that involve solution of sets of ATEs will have “Click Here to See What an Expert Might be Thinking at this Point” callouts that discuss the choice of the initial guess for that set of equations. If the original guess does not lead to convergence, that will be also be noted, and an explanation will be provided that describes the reasoning used to improve the initial guess so that conversion was achieved.</p>
<p>Similarly, some of the ATEs that are solved in <em>Reaction Engineering Basics</em> have multiple solutions. When that is the case, the example will describe how the initial guesses leading to each solution were generated. Also, <a href="section_4_cstr_analysis.html#sec-example_12_7_4" class="quarto-xref">Example&nbsp;<span>12.7.4</span></a> shows a method for determining whether a set of ATEs has multiple solutions and finding those solutions.</p>
</section>
<section id="sec-apndx_residuals_fcn" class="level5" data-number="F.5.1.1.2">
<h5 data-number="F.5.1.1.2" class="anchored" data-anchor-id="sec-apndx_residuals_fcn"><span class="header-section-number">F.5.1.1.2</span> The Residuals Function</h5>
<p>The other required input to an ATE solver is a residuals function. The purpose of the residuals function is to evaluate the residuals, given a guess for the solution. The engineer solving the ATEs must write the residuals function, but because it will be called by the ATE solver, the arguments passed to it and the values it returns are specified by the ATE solver. The arguments to the residuals function are guesses for the ATE variables, and it always returns the corresponding values of the ATE residuals.</p>
<p>If additional input variables are needed for calculating the residuals, that input must be made available to the residuals function by some means other than passing them as arguments. The documentation for the solver may suggest a preferred way to do this, such as by using a global variable or by using a pass-through function.</p>
</section>
</section>
<section id="how-ate-solvers-work" class="level4" data-number="F.5.1.2">
<h4 data-number="F.5.1.2" class="anchored" data-anchor-id="how-ate-solvers-work"><span class="header-section-number">F.5.1.2</span> How ATE Solvers Work</h4>
<p>Effectively, the ATE solver uses an iterative, trial and error process to find a solution.</p>
<ol type="1">
<li>The ATE residuals corresponding to the initial guess are calculated and retained as the best solution so far.</li>
<li>The ATE solver generates a new guess and calculates the corresponding ATE residuals.</li>
<li>The residuals corresponding to the new guess and the best solution so far are compared.</li>
<li>Whichever guess gave residuals that are closer to zero is retained as the best solution so far</li>
<li>Steps 2 through 4 are repeated until the solver determines that either
<ol type="a">
<li>the best solution so far is acceptably close to the exact solution, or</li>
<li>it cannot find a solution that is acceptably close to the exact solution.</li>
</ol></li>
</ol>
<p>For details on how the solver generates guesses, how it determines which set of residuals is closer to zero, and the criteria for the determinations in step 5, one can consult the documentation for the solver being used and reference works on numerical methods.</p>
</section>
<section id="sec-ate_solver_issues" class="level4" data-number="F.5.1.3">
<h4 data-number="F.5.1.3" class="anchored" data-anchor-id="sec-ate_solver_issues"><span class="header-section-number">F.5.1.3</span> Convergence and Solver Issues</h4>
<p>Ideally, the ATE residuals should get closer and closer to zero with each iteration. This is called convergence to a solution. The solution returned by the solver will not be exact, but it will be “very close” to the exact solution. Put differently, when a converged solution is found, the difference between the solution returned by the solver and the exact solution is negligible. If the solver is unable to converge to the point where the residuals are “very close” to zero, it will print an error message and/or return a flag variable indicating that it did not converge and why.</p>
<p>ATE solvers can fail to converge for different reasons, and for each reason, there are corrective actions that can be taken. Nonetheless, if the initial guess provided to the solver is “close enough” to a solution, the solver will converge. When the ATE solver fails to converge it is a good idea to check the inaccurate solution it returned. If an ATE variable in that solution is absurdly large or small, it often indicates that these is an error in the computer code or that the units being used in the calculations are not consistent. Otherwise, the inaccurage solution, together with a qualitative understanding of reactor performance, may suggest a way to revise the initial guess so that the solver does converge.</p>
<p>Finally, as already noted, sets of ATEs can have more than one solution. If a set of ATEs has multiple solutions, most ATE solvers will only find one of them. To find other solutions, the solver should be called again using a different initial guess.</p>
</section>
<section id="ate-solver-return-values" class="level4" data-number="F.5.1.4">
<h4 data-number="F.5.1.4" class="anchored" data-anchor-id="ate-solver-return-values"><span class="header-section-number">F.5.1.4</span> ATE Solver Return Values</h4>
<p>Even if it fails to converge, an ATE solver will return two things. The first is the best solution it was able to find and the second is some indicator of whether it converged. The latter might be a boolean variable or an integer where the value of the integer indicates convergence or the reason why the solver stopped iterating. Some solvers also return a text string that provides a brief explanation of the reason why it stopped trying to improve the solution.</p>
</section>
<section id="formulating-the-calculations-for-solving-ates" class="level4" data-number="F.5.1.5">
<h4 data-number="F.5.1.5" class="anchored" data-anchor-id="formulating-the-calculations-for-solving-ates"><span class="header-section-number">F.5.1.5</span> Formulating the Calculations for Solving ATEs</h4>
<p><a href="section_3_formulating_calcs.html#sec-3_formulate_calculations" class="quarto-xref">Chapter&nbsp;<span>8.4</span></a> outlines a workflow for completing reaction engineering tasks or assignments that includes formulating the calculations for solving equations numerically. When solving ATEs, the formulation of the calculations will include specifications for the residuals function and specifications for a reactor function.</p>
<p>The specifications for the residuals function should list the ATE variables as its arguments and the corresponding ATE residuals as its return variables. If any other variables need to be made available to the residuals function, its specifications should list them. Finally, the residuals function specifications should include an algorithm that lists a sequence of equations that can be used to calculate the ATE residuals starting from known constants, the ATE variables and the variables that have been made available to the residuals function.</p>
<p>The specifications for the reactor function may list arguments or it may indicate that it doesn’t take any arguments. More importantly, the specifications will list the ATE variables as the return values. The algorithm will define an initial guess for the ATE variables, make variables listed in the residuals function available to it, call the ATE solver, and return the solution found by the solver. Before returning the solution, it should verify that the solver did, in fact, converge, but typically the algorithm won’t list this in the sequence of equations.</p>
</section>
</section>
<section id="sec-apndx_solve_ivodes" class="level3" data-number="F.5.2">
<h3 data-number="F.5.2" class="anchored" data-anchor-id="sec-apndx_solve_ivodes"><span class="header-section-number">F.5.2</span> Solving IVODEs</h3>
<p>A set of IVODEs applies in an interval of the independent variable, beginning at its initial value and ending at its final value. There will be <span class="math inline">\(N\)</span> dependent variables and one independent variable in a set of <span class="math inline">\(N\)</span> IVODEs. The numerical solution of a set of IVODEs consists of sets of values (i. e. vectors) of the independent variable and each dependent variable. The sets all contain the same number of values. The values of the independent variable begin at its initial value and increase or decrease monotonically to its final value. For each dependent variable, the n<sup>th</sup> value is the value of that dependent variable corresponding to the n<sup>th</sup> value of the independent variable. A brief way of describing the numerical solution of a set of IVODEs is as sets of corresponding values of the independent and dependent variables spanning the range from their initial to their final values. An IVODE solver is a computer function that solves a set of IVODEs numerically. This sub-appendix describes the input required by IVODE solvers, how they work, the results they return, and potential issues that can arise when using them.</p>
<section id="ivode-solver-input" class="level4" data-number="F.5.2.1">
<h4 data-number="F.5.2.1" class="anchored" data-anchor-id="ivode-solver-input"><span class="header-section-number">F.5.2.1</span> IVODE Solver Input</h4>
<p>Typically an IVODE solver must be provided with three inputs. The first is the initial values of the independent and dependent variables. The second is a stopping criterion, and the third is a derivatives function. Depending on the mathematics software package being used, the solver may accept other input. The order and formatting of the arguments and return values will vary from one software packge to another.</p>
<section id="initial-values-and-stopping-criterion" class="level5" data-number="F.5.2.1.1">
<h5 data-number="F.5.2.1.1" class="anchored" data-anchor-id="initial-values-and-stopping-criterion"><span class="header-section-number">F.5.2.1.1</span> Initial Values and Stopping Criterion</h5>
<p>The engineer solving the IVODEs can usually define the initial value of the independent variable. Most commonly it is difined to equal zero. The value of each dependent variable when the independent variables is at its initial value are their initial values. With IVODEs, all of the initial values will be known or it will be possible to calculate them directly. Either the final value of the independent variable or the final value of one of the dependent variables will also be known, or it will be possible to calculate it directly. The identity of the variable for which the final value is known, along with that final value, make up the stopping criterion that must be provided as the second argument to the IVODE solver.</p>
</section>
<section id="sec-apndx_derivatives_fcn" class="level5" data-number="F.5.2.1.2">
<h5 data-number="F.5.2.1.2" class="anchored" data-anchor-id="sec-apndx_derivatives_fcn"><span class="header-section-number">F.5.2.1.2</span> The Derivatives Function</h5>
<p>The final argument that must be provided to the IVODE solver is the derivatives function. The purpose of the derivatives function is to evaluate the derivative of each dependent variable with respect to the independent variable, given values for the independent and dependent variables. It is written by the engineer who needs to solve the IVODEs, but is called by the IVODE solver. For that reason, the solver specifies the arguments and return values. Typically, the only arguments to the derivatives function are the independent and dependent variables and the only return values are the corresponding values of the derivatives. The solver sets how those quantities are formatted and the order in which they are passed or returned. If additional input variables are needed for evaluating the derivatives, that input must be made available to the derivatives function by some other means than passing them as arguments.</p>
</section>
</section>
<section id="how-ivode-solvers-work" class="level4" data-number="F.5.2.2">
<h4 data-number="F.5.2.2" class="anchored" data-anchor-id="how-ivode-solvers-work"><span class="header-section-number">F.5.2.2</span> How IVODE Solvers Work</h4>
<p>An IVODE solver starts from the initial values, as illustrated graphically in panel (a) of <a href="#fig-ivode-integration-step" class="quarto-xref">Figure&nbsp;<span>F.1</span></a> for any one of the dependent variables, <span class="math inline">\(y_i\)</span>. It isn’t possible to plot <span class="math inline">\(y_i\)</span> <em>vs.</em> <span class="math inline">\(z\)</span> at that point because <span class="math inline">\(y_i\left(z\right)\)</span> is not known. (Indeed, <span class="math inline">\(y_i\left(z\right)\)</span> is the solution to the IVODE.) Instead, the solver uses the derivatives function to calculate the value of each of the derivatives at <span class="math inline">\(\left(z_0,y_{i,0}\right)\)</span>. The derivative, <span class="math inline">\(\frac{dy_i}{dz}\)</span>, at that point is the unknown slope of the function at <span class="math inline">\(\left(z_0,y_{i,0}\right)\)</span>. This is shown graphically in panel (b) of <a href="#fig-ivode-integration-step" class="quarto-xref">Figure&nbsp;<span>F.1</span></a>.</p>
<div id="fig-ivode-integration-step" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ivode-integration-step-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./Graphics/IVODE_Integration_Step.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ivode-integration-step-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;F.1: Graphical Representation of an IVODE Integration Step. (a) The initial value. (b) The slope at that point. (c) Incrementally increasing <span class="math inline">\(z\)</span> and approximating the corresponding <span class="math inline">\(y_i\)</span>.
</figcaption>
</figure>
</div>
<p>The solver then approximates <span class="math inline">\(y_i\)</span> <em>vs.</em> <span class="math inline">\(z\)</span> as a straight line with that slope. It only does that over a small increment in the independent variable known as the integration step size and indicated in the figure as <span class="math inline">\(\Delta z\)</span>. The resulting point, <span class="math inline">\(\left(z_1,y_{i,1}\right)\)</span>, is shown in panel (c) of <a href="#fig-ivode-integration-step" class="quarto-xref">Figure&nbsp;<span>F.1</span></a>. This process is sometimes referred to as taking an integration step. Effectively, the solver uses the small straight line segment between <span class="math inline">\(\left(z_0,y_{i,0}\right)\)</span> and <span class="math inline">\(\left(z_1,y_{i,1}\right)\)</span> to approximate the true solution, <span class="math inline">\(y_i\left(z\right)\)</span>, in that interval. The accuracy of this approximation increases as <span class="math inline">\(\Delta z\)</span> decreases, so typically the solver uses small steps. A new integration step is then taken starting from <span class="math inline">\(\left(z_1,y_{i,1}\right)\)</span>.</p>
<p>Of course, the solver eventually must stop taking integration steps. After completing each step, the solver checks to determine whether making that step resulted in the stopping criterion being satisfied. If not, the solver takes another integration step. If the stopping criterion has been exceeded, the step size is adjusted to that the stopping criterion is satisfied exactly. The solver then returns the values of the dependent variables and the independent variable for all of the steps it took while solving the IVODEs, including those final interpolated values.</p>
<p>That was a simplified summary of how an IVODE solver works. For details on how the solver chooses the step size and other variations on how it works, one can consult the documentation for the solver being used and reference works on numerical methods.</p>
</section>
<section id="ivode-solver-issues" class="level4" data-number="F.5.2.3">
<h4 data-number="F.5.2.3" class="anchored" data-anchor-id="ivode-solver-issues"><span class="header-section-number">F.5.2.3</span> IVODE Solver Issues</h4>
<p>Generally IVODE solvers are quite robust when solving the kinds of ODEs encountered in introductory reaction engineering courses. However, there are three issues to be aware of. The first is failure to reach the known final value of a dependent variable. When the final value of a dependent variable is being used as the stopping criterion, many solvers require the user to provide <em>both</em> that final value <em>and</em> a final value for the independent variable. The solver then takes steps as described above, and after each step it checks to see whether either variable has reached its specified final value. If the final value of the <em>independent</em> variable is too small, the solver may reach that value first and stop. As a consequence, the known final value of the <em>dependent</em> variable will not have been reached, and the result that is returned will not span the full interval wherein IVODEs apply. Therefore it is important to check the solution and verify that the dependent variable reached its known final value.</p>
<p>To avoid having the solver stop because it reached the stopping criterion for the <em>independent</em> variable, it is tempting to specify a very large final value for it. This could result in the second solver issue. The initial step size used by the solver often increases when the final value of the independent variable is increased. In some extreme cases, if the initial step size becomes too large, the linear approximation indicated in <a href="#fig-ivode-integration-step" class="quarto-xref">Figure&nbsp;<span>F.1</span></a> is not valid, resulting in an inaccurate solution. Therefore, it is important to check that the step size was not too large. The solution that is returned will include the final value of the independent variable. If it is orders of magnitude smaller than the guess provided to the solver, the solution can be repeated using a final value for the independent variable that is only slightly greater than the value returned the first time the IVODEs were solved.</p>
<p>The third possible issue arises when solving sets of IVODEs where one of the dependent variables changes very abruptly over a very small range of the independent variable. The abrupt changes in that dependent variable may significantly affect the other dependent variables over a much broader range of the independent variable. Equations like this are called <strong>stiff ODEs</strong>, and they require special treatment of the step size. Therefore, when solving sets of ODEs, one should pay attention to whether any of the dependent variables change very abruptly as the independent variable changes. If they do, it is advisable to repeat the solution using a solver that is specifically tailored to stiff ODEs.</p>
</section>
<section id="ivode-solver-return-values" class="level4" data-number="F.5.2.4">
<h4 data-number="F.5.2.4" class="anchored" data-anchor-id="ivode-solver-return-values"><span class="header-section-number">F.5.2.4</span> IVODE Solver Return Values</h4>
<p>As noted above, the solution of a set of IVODEs is a set of corresponding values of the independent and dependent variables spanning the range from their initial to their final values. The first value in each set will be the initial value of that variable. The rest of the values in the set will be the values at the end of each integration step, ending with the variable’s final value.</p>
</section>
<section id="formulating-the-solution-of-ivodes" class="level4" data-number="F.5.2.5">
<h4 data-number="F.5.2.5" class="anchored" data-anchor-id="formulating-the-solution-of-ivodes"><span class="header-section-number">F.5.2.5</span> Formulating the Solution of IVODEs</h4>
<p><a href="section_3_formulating_calcs.html#sec-3_formulate_calculations" class="quarto-xref">Chapter&nbsp;<span>8.4</span></a> outlines a workflow for completing reaction engineering tasks or assignments that includes formulating the calculations for solving equations numerically. When solving IVODEs, the formulation of the calculations will include specifications for the derivatives function and specifications for a reactor function.</p>
<p>The specifications for the derivatives function should list the independent and dependent variables as its arguments and the corresponding derivatives of the dependent variables as its return variables. If any other input variables need to be made available to the derivatives function, its specifications should list them. The derivatives function specifications also should include an algorithm that lists a sequence of equations that can be used to calculate the derivatives starting from known constants, the independent and dependent variables and the variables that have been made available to the derivatives function.</p>
<p>The specifications for the reactor function may list arguments or it may indicate that it doesn’t take any arguments. More importantly, the specifications for the reactor function will list a set of corresponding values of the independent and dependent variables spanning the range from their initial to their final values as the return values. The algorithm will define the initial values and the stopping criterion, make variables listed in the derivatives function available to it, call the IVODE solver, and return the solution found by the solver. Before returning the solution, it should verify that the solver did not encounter any of the issues noted above</p>
</section>
</section>
<section id="sec-apndx_solve_daes" class="level3" data-number="F.5.3">
<h3 data-number="F.5.3" class="anchored" data-anchor-id="sec-apndx_solve_daes"><span class="header-section-number">F.5.3</span> Solving DAEs</h3>
<p>A set of IVODEs coupled to a set of ATEs comprise a set of DAEs. The numerical solution, then, is sets of corresponding values of the IVODE independent and dependent variables spanning the range from their initial to their final values togther with a set of values for the ATE variables that solve the ATEs.</p>
<p>To solve the DAEs encountered in <em>Reaction Engineering Basics,</em> a special DAE solver is not needed. They can be solved using an ATE solver and an IVODE solver. That means that both a residuals function and a derivatives function must be written when solving DAEs in <em>Reaction Engineering Basics.</em></p>
<section id="using-an-ate-solver-and-an-ivode-solver-to-solve-daes" class="level4" data-number="F.5.3.1">
<h4 data-number="F.5.3.1" class="anchored" data-anchor-id="using-an-ate-solver-and-an-ivode-solver-to-solve-daes"><span class="header-section-number">F.5.3.1</span> Using an ATE Solver and an IVODE Solver to Solve DAEs</h4>
<p>It was noted previously that there are two situations where DAEs are encountered in <em>Reaction Engineering Basics.</em> In the first situation, either the initial value of a dependent variable or a constant in the IVODEs is an additional unknown, but two final values are known. The ATE in this situation is implicit. As an example, suppose that <span class="math inline">\(y_1\)</span> and <span class="math inline">\(y_2\)</span> are IVODE dependent variables with known final values of <span class="math inline">\(y_{1,f}\)</span> and <span class="math inline">\(y_{2,f}\)</span>, and that <span class="math inline">\(C\)</span> is the additional unknown (either an initial value or a constant appearing in the IVODEs). The ATE component of the DAEs can then be written as shown in <a href="#eq-implicit_DAE_ATE" class="quarto-xref">Equation&nbsp;<span>F.18</span></a> where <span class="math inline">\(C\)</span> is the ATE variable. In effect it says <span class="math inline">\(C\)</span> has the value that results in <span class="math inline">\(y_2 = y_{2,f}\)</span> when the final value of <span class="math inline">\(y_1\)</span> is <span class="math inline">\(y_{1,f}\)</span>.</p>
<p><span id="eq-implicit_DAE_ATE"><span class="math display">\[
C \, : \, y_2\big\vert_{y_1 = y_{1,f}} = y_{2,f} \qquad \Rightarrow \qquad \epsilon_C = y_2\big\vert_{y_1 = y_{1,f}} - y_{2,f}
\tag{F.18}\]</span></span></p>
<p>In the second situation, both the initial and final values of one or more dependent variables are unknown, but they are related through explicit ATEs. In this case, the unknown <u>initial</u> values should be used as the ATE variables. The unknown final values can then be treated as additional unknowns appearing in the ATEs.</p>
<p>In both situations, the key to solving the DAEs numerically is to call the ATE solver first. When the ATE residuals function is called, a guess for the ATE variables will be passed to it as its only argument. Using that guess, the IVODEs can then be solved within the residuals function. Using the results from solving the IVODEs, the residuals can be evaluated. After the ATE solver converges to a solution for the ATEs, the IVODEs can be solved a final time using that solution.</p>
</section>
<section id="formulating-the-solution-of-daes" class="level4" data-number="F.5.3.2">
<h4 data-number="F.5.3.2" class="anchored" data-anchor-id="formulating-the-solution-of-daes"><span class="header-section-number">F.5.3.2</span> Formulating the Solution of DAEs</h4>
<p><a href="section_3_formulating_calcs.html#sec-3_formulate_calculations" class="quarto-xref">Chapter&nbsp;<span>8.4</span></a> outlines a workflow for completing reaction engineering tasks or assignments that includes formulating the calculations for solving equations numerically. When solving DAEs, the formulation of the calculations will include specifications for the residuals function, the derivatives function and a reactor function. The derivatives function specifications will be no different from when solving only IVODEs.</p>
<p>There are a few minor difference in the residuals function, compared to when solving ATEs. Specifically, the algorithm must begin by defining the initial values and stopping criterion for the IVODEs. If the ATE variable is a constant appearing in the IVODEs, the algorithm must also make that constant available to the derivatives function. Then it must call the IVODE solver and use the results it returns to calculate the ATE residuals.</p>
<p>The specifications for the reactor function are also slightly different compared to reactor functions for solving only ATEs or only IVODEs. The reactor function may or may not have any arguments. The return variables will be a set of ATE variables that solve the ATEs together with sets of corresponding values of the IVODE independent and dependent variables spanning the range from their initial to their final values. The algorithm for the reactor function will begin by defining a guess for the ATE variables and calling the ATE solver to get a solution of the ATEs. Then, using that solution, the initial values and stopping criterion for the IVODEs will be defined, and the IVODE solver will be called.</p>
</section>
</section>
<section id="sec-apndx_solve_bvodes" class="level3" data-number="F.5.4">
<h3 data-number="F.5.4" class="anchored" data-anchor-id="sec-apndx_solve_bvodes"><span class="header-section-number">F.5.4</span> Solving BVODEs</h3>
<p>A set of BVODEs applies in an interval of the independent variable, beginning at its lower bound (or lower limit) and ending at its upper bound. There will be <span class="math inline">\(N\)</span> dependent variables and one independent variable in a set of <span class="math inline">\(N\)</span> BVODEs. The numerical solution of a set of BVODEs consists of sets of values (i. e. vectors) of the independent variable and each dependent variable. The sets all contain the same number of values. The values of the independent variable begin at its lower bound and increase monotonically, ending at its upper bound. For each dependent variable, the n<sup>th</sup> value is the value of that dependent variable corresponding to the n<sup>th</sup> value of the independent variable. In other words, the numerical solution of a set of BVODEs consists of sets of corresponding values of the independent and dependent variables spanning the range from the lower bound of the independent variable to its upper bound. A BVODE solver is a computer function that solves a set of BVODEs numerically. This sub-appendix describes the input required by BVODE solvers, how they work, the results they return, and potential issues that can arise when using them.</p>
<section id="bvode-solver-input" class="level4" data-number="F.5.4.1">
<h4 data-number="F.5.4.1" class="anchored" data-anchor-id="bvode-solver-input"><span class="header-section-number">F.5.4.1</span> BVODE Solver Input</h4>
<p>Typically a BVODE solver must be provided with four inputs. The first is called the initial mesh and is described below. The second input is a guess for each of the dependent variables within the interval where the BVODEs apply as described below. The third and fourth inputs are a derivatives function and a boundary conditions residuals function. The order and formatting of the arguments and return values will vary from one software package to the next.</p>
<section id="the-initial-mesh-and-guess" class="level5" data-number="F.5.4.1.1">
<h5 data-number="F.5.4.1.1" class="anchored" data-anchor-id="the-initial-mesh-and-guess"><span class="header-section-number">F.5.4.1.1</span> The Initial Mesh and Guess</h5>
<p>The first input to a BVODE solver is called the initial mesh. The interval between the lower and upper bounds of the independent variable must be divided into <span class="math inline">\(N_i\)</span> intervals. This requires <span class="math inline">\(N_i+1\)</span> mesh points with the first being the lower bound and the last, the upper bound. The intervals between successive mesh points do not need to be equally sized. The engineer must choose <span class="math inline">\(N_i\)</span>, but typically it is not critical because the solver will adjust it.</p>
<p>Once an initial mesh has been defined, guesses for the values of each dependent variable at each mesh point are the second required input. That may seem like a large number of guesses, but often it is possible to get by with one of two simple guesses. The first simple guess is to simply set all of the dependent variables equal to zero at all mesh points. If the solver does not converge with that guess, a guess for the average value of each dependent variable over the entire mesh can be used as the guess for that dependent variable at each of the mesh points. Again, the specifics for providing the initial guess to the solver will depend upon the particular software package being used.</p>
</section>
<section id="the-derivatives-function" class="level5" data-number="F.5.4.1.2">
<h5 data-number="F.5.4.1.2" class="anchored" data-anchor-id="the-derivatives-function"><span class="header-section-number">F.5.4.1.2</span> The Derivatives Function</h5>
<p>The purpose of the derivatives function is to calculate the values of the derivatives at the mesh points, given the mesh points and the values of the dependent variables at the mesh points. The engineer solving the BVODEs must write the derivatives function, but because it will be called by the BVODE solver, the arguments to it and the values it returns are specified by the BVODE solver software package.</p>
<p>There are two common specifications for the arguments and return values for the derivatives function. Some software packages specify that the arguments are a single mesh point and the corresponding values of the dependent variables at that mesh point. In this case, the specified return values are the values of the derivatives at that one mesh point. Other software packages specify that the arguments are the full set of mesh points (typically in the form of a vector) and the full set of dependent variables values at those mesh points (typcially as a matrix). In this case the specified return values are the values of the derivatives at each of the mesh points (also typically as a matrix).</p>
<p>In <em>Reaction Engineering Basics,</em> BVODE solutions are formulated assuming that the arguments to the derivatives function are one of the mesh points along with the values of the dependent variables at that mesh point, and that the values of the derivative of each dependent variable with respect to the independent variable at that mesh point are returned. However each formulation in the book notes that some software packages may specify the full set of mesh points and the values of dependent variables at all of the mesh points as the arguments and the values of the derivatives at all of the mesh point as the return values.</p>
<p>In some situations, the derivatives function may need the values of variables other than those passed to it as arguments. Because the arguments are specified by the mathematics software package being used, any such quantities must be made available to the derivatives function by some other means than being passed to it as arguments.</p>
</section>
<section id="the-boundary-conditions-residuals-function" class="level5" data-number="F.5.4.1.3">
<h5 data-number="F.5.4.1.3" class="anchored" data-anchor-id="the-boundary-conditions-residuals-function"><span class="header-section-number">F.5.4.1.3</span> The Boundary Conditions Residuals Function</h5>
<p>Boundary conditions are ATEs that must be satisfied by the dependent variables at the upper and lower bounds of the independent variable. They must be written as residual expressions so that the third required input, the boundary conditions residuals function, can evaluate them, given the values of the dependent variables at the two bounds. As is the case for the derivatives function, the engineer solving the BVODEs must write the boundary conditions residuals function, but because it will be called by the BVODE solver, the arguments to it and the values it returns are specified by the BVODE solver software package.</p>
<p>BVODE solvers commonly specify that the arguments to the boundary conditions residuals function are the values of the dependent variables at each of the boundaries and the return values are the corresponding values of the residuals. The specifics of how these arguments and return values are formatted will again depend upon the software package being used. Very often the values of the dependent variables at each of the boundaries are passed to the boundary conditions residuals function as separate vectors while the residuals are returned as a single vector.</p>
<p>As with the derivatives function, the boundary conditions residuals function may need the values of variables other than those passed to it as arguments. Because the arguments are specified by the mathematics software package being used, any such quantities must be made available to the boundary conditions residuals function by some other means than being passed to it as arguments.</p>
</section>
</section>
<section id="how-bvode-solvers-work" class="level4" data-number="F.5.4.2">
<h4 data-number="F.5.4.2" class="anchored" data-anchor-id="how-bvode-solvers-work"><span class="header-section-number">F.5.4.2</span> How BVODE Solvers Work</h4>
<p>A BVODE solver solves the equations using a mesh where the span of the independent variable, <span class="math inline">\(z\)</span> is divided into <span class="math inline">\(N_i\)</span> intervals using <span class="math inline">\(N_i+1\)</span> mesh points with <span class="math inline">\(z_1\)</span> equal to the lower bound, <span class="math inline">\(z_{lb}\)</span>, and <span class="math inline">\(z_{N_i+1}\)</span> equal to the upper bound, <span class="math inline">\(z_{ub}\)</span>. The intervals between successive mesh points do not need to be equally sized.</p>
<p>To simplify the notation, consider just one dependent variable, <span class="math inline">\(y\)</span>. Functions that contain undetermined coefficients are used to approximate <span class="math inline">\(y\)</span> in each interval. Cubic polynomials are a common approximating function. When using a cubic polynomial as the approximating function, the value of <span class="math inline">\(y\)</span> within the <span class="math inline">\(k^{th}\)</span> interval (i. e. between <span class="math inline">\(z_k\)</span> and <span class="math inline">\(z_{k+1}\)</span>) is approximated by <a href="#eq-cubic_approx_func" class="quarto-xref">Equation&nbsp;<span>F.19</span></a>, and its derivative is used to approximate <span class="math inline">\(\frac{dy}{dz}\)</span> within the <span class="math inline">\(k^{th}\)</span> interval, <a href="#eq-cubic_approc_deriv" class="quarto-xref">Equation&nbsp;<span>F.20</span></a>.</p>
<p><span id="eq-cubic_approx_func"><span class="math display">\[
y = a_k z^3 + b_k z^2 + c_k z + d_k \,; \quad z_k \le z \le z_{k+1}
\tag{F.19}\]</span></span></p>
<p><span id="eq-cubic_approc_deriv"><span class="math display">\[
\frac{dy}{dz} = 3 a_k z^2 + 2 b_k z + c_k \,; \quad z_k \le z \le z_{k+1}
\tag{F.20}\]</span></span></p>
<p>If there are <span class="math inline">\(N_i\)</span> intervals, this introduces <span class="math inline">\(4N_i\)</span> undetermined coefficients, <span class="math inline">\(a_1\)</span>, <span class="math inline">\(b_1\)</span>, <span class="math inline">\(c_1\)</span>, and <span class="math inline">\(d_1\)</span> through <span class="math inline">\(a_{N_i}\)</span>, <span class="math inline">\(b_{N_i}\)</span>, <span class="math inline">\(c_{N_i}\)</span>, and <span class="math inline">\(d_{N_i}\)</span>. Finding the values of those <span class="math inline">\(4N_i\)</span> undetermined coefficients yields an approximation for <span class="math inline">\(y\)</span> that spans the full interval from <span class="math inline">\(z=z_{lb}\)</span> to <span class="math inline">\(z=z_{ub}\)</span>. Doing so requires a set of <span class="math inline">\(4N_i\)</span> independent equations containing the undetermined coefficients.</p>
<p>Each of the interior mesh points, <span class="math inline">\(z_2\)</span> through <span class="math inline">\(z_{N_i}\)</span> is the end of one interval and the start of the next. To prevent the approximation of <span class="math inline">\(y\)</span> from being discontinuous, at each interior mesh point, <span class="math inline">\(z_k\)</span>, the values of <span class="math inline">\(y\)</span> predicted by the two approximating functions on either side of <span class="math inline">\(z_k\)</span> are required to be equal. This results in <span class="math inline">\(N_i-1\)</span> equations like that given in <a href="#eq-cubic_continuous" class="quarto-xref">Equation&nbsp;<span>F.21</span></a>. In addition a boundary condition will provide an equation that contains the value of <span class="math inline">\(y\)</span> at either <span class="math inline">\(z=z_{lb}\)</span> or <span class="math inline">\(z=z_{ub}\)</span>. This gives a total of <span class="math inline">\(N_i\)</span> equations containing the <span class="math inline">\(4N_i\)</span> undetermined coefficients.</p>
<p><span id="eq-cubic_continuous"><span class="math display">\[
\begin{align}
a_{k-1} z_k^3 &amp;+ b_{k-1} z_k^2 + c_{k-1} z_k + d_{k-1} \\&amp;= a_k z_k^3 + b_k z_k^2 + c_k z_k + d_k  \end{align} \qquad k = 2, 3, \cdots, N_i
\tag{F.21}\]</span></span></p>
<p>To generate <span class="math inline">\(3N_i\)</span> additional equations, three collocation points are chosen within each interval. Typically the two end points and the mid-point of the interval are used. At each of these collocation points, the derivatives function can be used to calculate <span class="math inline">\(\frac{dy}{dz}\)</span> which then can be substituted in <a href="#eq-cubic_approc_deriv" class="quarto-xref">Equation&nbsp;<span>F.20</span></a>. Doing this at three collocation points within each interval brings the total number of equations to <span class="math inline">\(4N_i\)</span>.</p>
<p>The <span class="math inline">\(4N_i\)</span> equations containing the <span class="math inline">\(4N_i\)</span> undetermined coefficients are non-linear, so they are solved numerically to find the values of the coefficients, <span class="math inline">\(a_1\)</span>, <span class="math inline">\(b_1\)</span>, <span class="math inline">\(c_1\)</span>, and <span class="math inline">\(d_1\)</span> through <span class="math inline">\(a_{N_i}\)</span>, <span class="math inline">\(b_{N_i}\)</span>, <span class="math inline">\(c_{N_i}\)</span>, and <span class="math inline">\(d_{N_i}\)</span>. Converting the initial guess for the dependent variables at the mesh points (one of the BVODE arguments) to initial guesses for these coefficients is handled internally by the BVODE solver, as is solving the equations to find the coefficients.</p>
<p>When solving a set of BVODEs, there will be multiple dependent variables, and the approach outlined here is applied to each dependent variable. Typically the BVODE solver will adjust the number of intervals used in the calculations to ensure an accurate solution.</p>
</section>
<section id="bvode-solver-issues" class="level4" data-number="F.5.4.3">
<h4 data-number="F.5.4.3" class="anchored" data-anchor-id="bvode-solver-issues"><span class="header-section-number">F.5.4.3</span> BVODE Solver Issues</h4>
<p>Effectively the BVODE solver converts the ODEs into ATEs and solves the ATEs. As such, a BVODE solver may encounter the same issues as an ATE solver. In addition, the mesh is used to convert the ODEs into ATEs, and this can cause issues. Specifically, if a dependent variable changes over a small sub-interval of the independent variable, more mesh points may be needed in that sub-interval than in intervals were the change in the dependent variable is smaller. If such an issue arises, the number and spacing of the initial mesh points can be adjusted.</p>
</section>
<section id="bvode-solver-return-values" class="level4" data-number="F.5.4.4">
<h4 data-number="F.5.4.4" class="anchored" data-anchor-id="bvode-solver-return-values"><span class="header-section-number">F.5.4.4</span> BVODE Solver Return Values</h4>
<p>As noted above, the solution of a set of BVODEs is a set of corresponding values of the independent and dependent variables spanning the range from the lower bound of the independent variable to its upper bound. The number of values in each set is not known because the solver may change both the number of mesh points and their locations as it solves the equations. Nonetheless, the first value will correspond to the lower bound and the last, to the upper bound.</p>
</section>
<section id="formulating-the-solution-of-bvodes" class="level4" data-number="F.5.4.5">
<h4 data-number="F.5.4.5" class="anchored" data-anchor-id="formulating-the-solution-of-bvodes"><span class="header-section-number">F.5.4.5</span> Formulating the Solution of BVODEs</h4>
<p>Using the assignment completion workflow described in <a href="section_3_formulating_calcs.html#sec-3_formulate_calculations" class="quarto-xref">Chapter&nbsp;<span>8.4</span></a>, will require writing specifications for the derivatives function and the boundary conditions residuals function. The specifications for the derivatives function are essentially the same as when solving IVODEs. They should list the arguments passed to it, quantities that must be made available to it by other means, the quantities it returns, and its algorithm. As already noted, the arguments might be the independent and dependent variables for a single mesh point, or they might be for all of the mesh points, depending on the solver being used. The algorithm should calculate any additional unknowns and the evaluate and return the derivatives at the mesh point(s) passed to the function.</p>
<p>The specifications for the boundary conditions residuals function should similarly list the dependent variables at the upper and lower bounds as its arguments. Quantities that must be made available to it by other means should be listed. The boundary conditions residuals calculated using the argument should be liste as the return values. The algorithm should consist of residual expressions corresponding to the boundary conditions.</p>
</section>
</section>
</section>
<section id="sec-apndx_parameter_est" class="level2" data-number="F.6">
<h2 data-number="F.6" class="anchored" data-anchor-id="sec-apndx_parameter_est"><span class="header-section-number">F.6</span> Estimating Parameters</h2>
<p>Parameter estimation involves using experimental data to find the best values for unknown, constant parameters appearing in a model of the experiments that generated the experimental data. This is sometimes called fitting the model to the data. In each experiment, the values of one or more <em>adjusted experimental input variables</em> are set by the person doing the experiments, and then the value of an <em>experimental response</em> is measured. In <em>Reaction Engineering Basics</em> only experiments with a single experimental response are considered. Every experiment that is performed involves the same set of adjusted input variables and the same experimental response, but their values are different from experiment to experiment.</p>
<p>Most readers of <em>Reaction Engineering Basics</em> will be familiar fitting a linear model to experimental data using least squares. This can be done using a calculator, a spreadsheet, or a least-squares fitting function from a mathematics software package. Fitting linear models to experimental data is not considered in this appendix. Here the focus is on using numerical methods to fit arbitrary models to experimental data. The models may include numerical solution of sets of equations as described above. The computer functions from mathematics software packages that are used to fit models to data will be referred to here as fitting functions.</p>
<section id="fitting-function-input" class="level3" data-number="F.6.1">
<h3 data-number="F.6.1" class="anchored" data-anchor-id="fitting-function-input"><span class="header-section-number">F.6.1</span> Fitting Function Input</h3>
<p>Generally a fitting function must be provided with four inputs. The first is an initial guess for the parameters being estimated, the second is the values of the adjusted input variables for each of the experiments in the data set, the third is the corresponding values of the experimental response for each experiment, and the fourth is a predicted response function.</p>
<section id="the-initial-guess-for-the-parameters-being-estimated" class="level4" data-number="F.6.1.1">
<h4 data-number="F.6.1.1" class="anchored" data-anchor-id="the-initial-guess-for-the-parameters-being-estimated"><span class="header-section-number">F.6.1.1</span> The Initial Guess for the Parameters being Estimated</h4>
<p>Guessing values for the parameters being estimated can be challenging. Typically the engineer does not have any idea what the value may be, and for some parameters the range of possible values can span ten orders of magnitude or more. In this situation, if the initial guess is not sufficiently close to the actual value of the parameter, the fitting function may fail to converge because it is not making progress. One way to reduce the likelihood of this happening is to use the base-10 logarithm of the parameter instead of the parameter itself. That is, if <span class="math inline">\(k_0\)</span> is the actual parameter of interest in the model, re-write the model replacing <span class="math inline">\(k_0\)</span> with <span class="math inline">\(10^\beta\)</span>. Then perform parameter estimation to find the best value of <span class="math inline">\(\beta\)</span>. When the possible range of <span class="math inline">\(k_0\)</span> is between 10<sup>-20</sup> and 10<sup>20</sup>, the corresponding range of <span class="math inline">\(\beta\)</span> is between -20 and 20, making it easier to guess. Once the best value <span class="math inline">\(\beta\)</span> has been found, the best value of <span class="math inline">\(k_0\)</span> is simply calculated as <span class="math inline">\(k_0 = 10^\beta\)</span>. This approach is illustrated in <a href="section_6_data_generation.html#sec-example_18_6_2" class="quarto-xref">Example&nbsp;<span>18.6.2</span></a>.</p>
</section>
<section id="the-experimental-data" class="level4" data-number="F.6.1.2">
<h4 data-number="F.6.1.2" class="anchored" data-anchor-id="the-experimental-data"><span class="header-section-number">F.6.1.2</span> The Experimental Data</h4>
<p>The adjusted experimental inputs and the corresponding experimental response for the experiment are typically available as a table or spreadsheet file. This makes it easy to create a matrix containing the experimental inputs and a vector containing the corresponding experimental responses. Those are the formats most often used to pass the experimental inputs and responses to the fitting function.</p>
</section>
<section id="the-predicted-responses-function" class="level4" data-number="F.6.1.3">
<h4 data-number="F.6.1.3" class="anchored" data-anchor-id="the-predicted-responses-function"><span class="header-section-number">F.6.1.3</span> The Predicted Responses Function</h4>
<p>The purpose of the predicted response function is to calculate the experimental responses predicted by the model for each experiment, given a guess for the values of the parameters. The predicted responses function is written by the engineer, but it is called by the numericaly fitting function. For this reason, the software package that provides the numerical fitting function specifies arguments that must be provided to the predicted responses function, the form in which they are provided, the values returned by the fitting function, and the form in which they are returned. Nonetheless, the arguments to the predicted responses function will include values for the model parameters and the set of adjusted experimental inputs from all of the experiments. The predicted responses function will return the set of model-predicted responses for all of the experiments.</p>
<p>Calculating the model-predicted response for each experiment will typically entail solving the reactor design equations for the reactor used in the experiments. The reactor design equations will usually be ATEs or IVODEs. Consequently, the algorithm for the predicted responses function will typically include calling a reactor function, and the reactor function will call an appropriate equation solver.</p>
</section>
</section>
<section id="how-fitting-functions-work" class="level3" data-number="F.6.2">
<h3 data-number="F.6.2" class="anchored" data-anchor-id="how-fitting-functions-work"><span class="header-section-number">F.6.2</span> How Fitting Functions Work</h3>
<p>A fitting function works in much the same manner as an ATE solver (see <a href="#sec-apndx_solve_ates" class="quarto-xref"><span>Section F.5.1</span></a>) except that instead of finding values of unknowns that cause a set of residuals to equal zero it finds values of model parameters that minimize the sum of the squares of the errors between the experimental responses and the model-predicted responses, <a href="#eq-sum_of_squares_of_errors" class="quarto-xref">Equation&nbsp;<span>F.22</span></a>.</p>
<p><span id="eq-sum_of_squares_of_errors"><span class="math display">\[
\Psi = \sum_i \left(  y_{i,expt} - y_{i,model} \right)^2
\tag{F.22}\]</span></span></p>
<p>In essence, the fitting function finds the best parameter values by trial and error.</p>
<ol type="1">
<li>Using the initial guess for the model parameters, it calls the predicted responses function to get the model-predicted responses and then calculates <span class="math inline">\(\Psi\)</span> using <a href="#eq-sum_of_squares_of_errors" class="quarto-xref">Equation&nbsp;<span>F.22</span></a>.</li>
</ol>
<ul>
<li>It saves the initial guess and the corresponding <span class="math inline">\(\Psi\)</span> as the best values.</li>
<li>It repeatedly
<ul>
<li>generates an improved guess</li>
<li>calculates <span class="math inline">\(\Psi\)</span> as above, and</li>
<li>if <span class="math inline">\(\Psi\)</span> is less than the best <span class="math inline">\(\Psi\)</span> it saves the improved guess and corresponding <span class="math inline">\(\Psi\)</span> as the best values.</li>
</ul></li>
<li>It stops generating new guesses when it is unable to generate an improved guess that results in a smaller <span class="math inline">\(\Psi\)</span>.</li>
</ul>
</section>
<section id="fitting-function-issues" class="level3" data-number="F.6.3">
<h3 data-number="F.6.3" class="anchored" data-anchor-id="fitting-function-issues"><span class="header-section-number">F.6.3</span> Fitting Function Issues</h3>
<p>Parameter estimation as described above is an iterative process. Ideally, as the fitting function generates improved guesses, the corresponding sum of the squares of the errors gets smaller and smaller. This is called convergence. The fitting function uses a set of convergence criteria to determine when it stops generating guesses and returns the current best values. A few possible issues should be kept in mind when performing numerical parameter estimation. The first is that the fitting function may converge to a local minimum of the sum of the squares of the errors and not the global minimum. In this situation, the fitting function would return a flag indicating that it converged (see return values, below), but the results would likely indicate that the model is not accurate. The apparent inaccuracy, though, is due to convergence to a local minimum and not necessariy due to the model. That is, if the fitting function converged to the global minimum, the model might actually prove to be quite accurate. One way to try to detect this situation is to repeat the parameter estimation using a very different initial guess. If the solver converges to a different set of estimated parameters, that indicates that one (or possibly both) of the sets of estimated parameters corresponds to a local minimum. If a wide range of initial guesses always leads to the same parameter estimates, that <em>may</em> suggest the a global minimum has been found.</p>
<p>The second issue arises when the experimental responses span several orders of magnitude. In this situation, the value of the sum of the squares of the errors, <span class="math inline">\(\Psi\)</span> in <a href="#eq-sum_of_squares_of_errors" class="quarto-xref">Equation&nbsp;<span>F.22</span></a>, may be dominated by the responses with the greater magnitude. This can result in a fitted model that is accurate under conditions where the response is larger, but less accurate when the response is smaller. One way to address this is to minimize the sum of the squares of the relative errors, <a href="#eq-sum_of_squares_of_rel_errors" class="quarto-xref">Equation&nbsp;<span>F.23</span></a>, instead of the sum of the squares of the absolute errors, <a href="#eq-sum_of_squares_of_errors" class="quarto-xref">Equation&nbsp;<span>F.22</span></a>.</p>
<p><span id="eq-sum_of_squares_of_rel_errors"><span class="math display">\[
\Psi = \sum_i \left( \frac{ y_{i,expt} - y_{i,model}}{y_{i,expt}} \right)^2
\tag{F.23}\]</span></span></p>
</section>
<section id="fitting-function-return-values" class="level3" data-number="F.6.4">
<h3 data-number="F.6.4" class="anchored" data-anchor-id="fitting-function-return-values"><span class="header-section-number">F.6.4</span> Fitting Function Return Values</h3>
<p>The fitting function will return the best estimates for the parameters that it was able to find. Typically it will aslo return a flag or message that indicates whether it converged and why it stopped iterating. Most fitting functions can also be made to return a variety of other variables. In most cases the mathematics software package being used will describe how to cause the fitting function to also return the coefficient of determination, <span class="math inline">\(R^2\)</span>, and either the standard error or the 95% confidence interval for each parameter.</p>
</section>
<section id="assessing-the-accuracy-of-the-fitted-model" class="level3" data-number="F.6.5">
<h3 data-number="F.6.5" class="anchored" data-anchor-id="assessing-the-accuracy-of-the-fitted-model"><span class="header-section-number">F.6.5</span> Assessing the Accuracy of the Fitted Model</h3>
<p>The fitting function will return the best estimates for the parameters in the model, but that does not necessarily result in an accurate model. The mathematical form of the model may be incapable predicting the variation of the experimental responses no matter what values are used for the parameters. For this reason, it is necessary to assess the accuracy of the fitted model.</p>
<p>There are several statistical indicators that a fitted model accurately represents the data to which it was fit. First, the coefficient of determination, <span class="math inline">\(R^2\)</span>, will be close to 1. The uncertainty in most of the estimated parameters, if not all, will be small relative to the extimated value. That is, the standard error for the parameter will be small compated to the value of the parameter or the upper and lower limits of the 95% confidence interval will be close to the estimated value of the parameter.</p>
<p>As noted in <a href="section_6_data_generation.html" class="quarto-xref"><span>Chapter 18</span></a>, there could be a few paramters for which the uncertainty is large but the model is still accurate. This could indicate one of three possibilities. First, the values to which the adjusted input variables were set in the experiments may not allow accurate resolution of those parameters that have high uncertainty. Second, parameters with higher uncertainty may be mathematically coupled to each other (e. g. the model-predicted response may only depend on the product of two parameters so that the individual parameters can have any values as long as their product has the optimum value). Third, the parameters with high uncertainty may not be needed, and there may be a simpler model with fewer parameters that is equally accurate.</p>
<p>Two different kinds of graphs are helpful when assessing the accuracy of a numerical model. The first is callea a parity plot. In a parity plot the model-predicted responses are plotted versus the experimental responses as data points. The parity line, <span class="math inline">\(y_{expt} = y_{model}\)</span>, is then added to the graph. If there were no random errors in the experimental data and the model was exact, then every experimental data point in a parity plot would fall on the parity line. If the model is accurate, the deviations from data from the parity line will be small.</p>
<p>The second type of graph used with numerical models is called a residuals plot. The experiment residuals are the differences between the experimental responses and the model-predicted responses for the set of experiments, <a href="#eq-experiment_residual" class="quarto-xref">Equation&nbsp;<span>F.24</span></a>. A set of residuals plots can be created wherein the residuals are plotted versus each of the experimental adjusted input variables. If there were no random errors in the experimental data and the model was exact, then every experiment residual would equal zero and fall on the horizontal axis. If there are trends in the deviations of the experiment residuals, it may indicate that the model does not fully capture the effect of the plotted experimental input upon the response.</p>
<p><span id="eq-experiment_residual"><span class="math display">\[
\epsilon_{expt,i} = y_{i,expt} - y_{i,model}
\tag{F.24}\]</span></span></p>
<p>In <em>Reaction Engineering Basics</em> experiment residuals are only plotted against each of the adjusted inputs. However, a residuals plot can be generated for any aspect of the experiments that might affect the results of an experiment. For example the experiment residuals could be plotted against the vendor from whom a reagent was purchased to see whether the source of the reagent was affecting the results.</p>
<p>Ultimately, deciding whether the model is sufficiently accurate is a judgement call. To summarize, the following criteria are satisfied by an accurate model.</p>
<ul>
<li>The coefficient of determination, <span class="math inline">\(R^2\)</span>, is nearly equal to 1.</li>
<li>The uncertainty in most, if not all, of model parameters is small compared to the parameter’s value.
<ul>
<li>When using standard errors of the parameters, they are small compared to the parameter value.</li>
<li>When using 95% confidence intervals, the upper and lower limits of the interval are close to the parameter value.</li>
</ul></li>
<li>The points in the parity plot are all close to a diagonal line passing through the origin.</li>
<li>In each residuals plot, the points scatter randomly about the horizontal axis, and no systematic deviations are apparent.</li>
</ul>
</section>
<section id="formulating-the-fitting-of-a-model-to-experimental-data" class="level3" data-number="F.6.6">
<h3 data-number="F.6.6" class="anchored" data-anchor-id="formulating-the-fitting-of-a-model-to-experimental-data"><span class="header-section-number">F.6.6</span> Formulating the Fitting of a Model to Experimental Data</h3>
<p>Using the assignment completion workflow described in <a href="section_3_formulating_calcs.html#sec-3_formulate_calculations" class="quarto-xref">Chapter&nbsp;<span>8.4</span></a>, will require writing specifications for the predicted responses function and an estimated parameters function.</p>
<p>The specifications for the predicted responses function will list the adjusted experimental inputs and a guess for the parameters to be estimated as the arguments and the model predicted responses as the return variables. The algorithm will loop through the experiments. For each experiment it will typically call a reactor model to solve the design equations for the reactor and then use the results to calculate the predicted response. When analyzing kinetics data, the reactor model will typically be a set of ATEs or IVODEs, and the reactor function will call either a residuals function or a derivatives function. In this situation, the predicted responses function algorithm must make the parameters to be estimated available to the residuals or derivatives function before calling the reactor function.</p>
<p>The estimated parameters function specifications will list the adjusted experimental inputs and the experimental responses as arguments. The return variables will be the best estimates for the parameters being estimated, the standard error or the 95% confidence intervals for the parameter estimates, and the coefficient of determination. The algorithm will define an intial guess for the parameters to be estimated and then call the fitting function. Before returning the results, it should check that the fitting function converged.</p>
</section>
</section>
<section id="symbols-used-in-this-appendix" class="level2" data-number="F.7">
<h2 data-number="F.7" class="anchored" data-anchor-id="symbols-used-in-this-appendix"><span class="header-section-number">F.7</span> Symbols Used in This Appendix</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Symbol</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(a_i\)</span></td>
<td style="text-align: left;">Undetermined coefficient in a cubic approximating polynomial.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(b_i\)</span></td>
<td style="text-align: left;">Undetermined coefficient in a cubic approximating polynomial.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(c_i\)</span></td>
<td style="text-align: left;">Undetermined coefficient in a cubic approximating polynomial.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(d_i\)</span></td>
<td style="text-align: left;">Undetermined coefficient in a cubic approximating polynomial.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(f_j\)</span></td>
<td style="text-align: left;">Derivative function.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(g_j\)</span></td>
<td style="text-align: left;">Function of the independent and dependent variables in a general set of ODEs.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(_{lb}\)</span></td>
<td style="text-align: left;">Subscript denoting the lower bound.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(m_{i,j}\)</span></td>
<td style="text-align: left;">Coefficient in the matrix form of a set of differential equations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\dot{n}_{i,k}\)</span></td>
<td style="text-align: left;">Molar flow rate of reagent <span class="math inline">\(i\)</span> in flow stream <span class="math inline">\(k\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(r\)</span></td>
<td style="text-align: left;">Reaction rate.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(t\)</span></td>
<td style="text-align: left;">Time.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(_{ub}\)</span></td>
<td style="text-align: left;">Subscript denoting the upper bound.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(y_i\)</span></td>
<td style="text-align: left;">Dependent variable in a general set of ODEs.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(z\)</span></td>
<td style="text-align: left;">Independent variable in a general set of ODEs or distance from the reactor inlet.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(C\)</span></td>
<td style="text-align: left;">Unknown IVODE constant or initial value.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(C_{i,k}\)</span></td>
<td style="text-align: left;">Concentration of reagent <span class="math inline">\(i\)</span> in flow stream <span class="math inline">\(k\)</span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\boldsymbol{M}\)</span></td>
<td style="text-align: left;">Mass matrix.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(N\)</span></td>
<td style="text-align: left;">Number of equations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(N_i\)</span></td>
<td style="text-align: left;">Number of intervals in a BVODE mesh.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(R^2\)</span></td>
<td style="text-align: left;">Coefficient of determination.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(V\)</span></td>
<td style="text-align: left;">Reacting fluid volume.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\dot{V}\)</span></td>
<td style="text-align: left;">Volumetric flow rate.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\epsilon\)</span></td>
<td style="text-align: left;">Residual.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\Delta z\)</span></td>
<td style="text-align: left;">Integration step size.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\Psi\)</span></td>
<td style="text-align: left;">Sum of the squares of the errors.</td>
</tr>
</tbody>
</table>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./apndx_derivations.html" class="pagination-link" aria-label="Derivation of Model Equations">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Derivation of Model Equations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./apndx_useful_eqns.html" class="pagination-link" aria-label="Frequently Used Equations">
        <span class="nav-page-text"><span class="chapter-number">G</span>&nbsp; <span class="chapter-title">Frequently Used Equations</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>